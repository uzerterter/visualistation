<!DOCTYPE html>
<meta charset="utf-8">
<script src="http://d3js.org/d3.v3.min.js"></script>

<style>
    body {
        display: flex;
        justify-content: center; /* Center children horizontally */
        align-items: center; /* Center children vertically */
        height: 100vh; /* Full viewport height */
        margin: 0; /* Remove default margin */
        }

    svg {
        width: 100vw; /* 100% of viewport width */
        height: 100vh; /* 100% of viewport height */
        background: #EAE2B7;
    }

    /* Default state style */
    .state {
        fill: #FCBF49;
        stroke: #fff;
        stroke-width: 1.25px;
        opacity: 0.85;
    }

    /* Hover state style for individual states */
    .state:hover {
        fill: #F77F00;
    }

    .state.active {
        fill: #F77F00;
    }

</style>

<body>

    <div id="map"></div>

    <script>


        var width = window.innerWidth,
            height = window.innerHeight,
            margin = { top: 0, left: 0, right: 0, bottom: 0 },
            geoPath;

        var focused = null;

        // _____________________________________________

        // Define your specific functions for each state here

        function function1() {
            console.log("Function for state 1 called");
            // Implement functionality
        }

        function function12() {
            console.log("Function for state 12 called");
        }

        // _____________________________________________

        var svg = d3.select("body")
            .append("svg")


        var g = svg.append("g")
            .append("g")
            .attr("id", "states");

        var focused = null;

        d3.json("./dataBundesLander.json", function (collection) {

            var bounds = d3.geo.bounds(collection),
                bottomLeft = bounds[0],
                topRight = bounds[1],
                rotLong = -(topRight[0] + bottomLeft[0]) / 2,
                center = [(topRight[0] + bottomLeft[0]) / 2 + rotLong, (topRight[1] + bottomLeft[1]) / 2],

                // Default scale projection
                projection = d3.geo.albers()
                    .parallels([bottomLeft[1], topRight[1]])
                    .rotate([rotLong, 0, 0])
                    .translate([width / 2, height / 2])
                    .center(center),

                bottomLeftPx = projection(bottomLeft),
                topRightPx = projection(topRight),
                scaleFactor = 1.00 * Math.min(width / (topRightPx[0] - bottomLeftPx[0]), height / (-topRightPx[1] + bottomLeftPx[1])),

                projection = d3.geo.albers() // Size of the map
                    .parallels([bottomLeft[1], topRight[1]])
                    .rotate([rotLong, 0, 0])
                    .translate([width / 2, height / 2])
                    .scale(scaleFactor * 1000)
                    .center(center);

            geoPath = d3.geo.path().projection(projection);

            g.selectAll("path.feature") // Necessary
                .data(collection.features)
                .enter()
                .append("path")
                .attr("class", "state")
                .attr("d", geoPath)
                .on("click", function(d) {
                    clickPath(d); // Call clickPath function when a path is clicked
                });


        });

        function handleStateClick(stateId) {
            var stateFunctionMap = {
                1: function1,
                12: function12,
                // Map other state IDs to their respective functions
            };

            if (stateFunctionMap[stateId]) {
                stateFunctionMap[stateId]();
            } else {
                console.log("No specific function for state ID " + stateId);
            }
        }

        function clickPath(d) {
            var stateId = d.properties.ID_1; // Get the state ID from the data

            if (focused === d) {
                // If the same state is clicked again, reset the zoom
                resetZoom();
            } else {
                // Calculate the new scale and translate values for zooming in
                var centroid = geoPath.centroid(d),
                    x = centroid[0],
                    y = centroid[1],
                    k = 1.5;   // scaling factor
                focused = d;

                // Apply the zoom transform to the map
                g.transition()
                    .duration(750)
                    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + k + ")translate(" + -x + "," + -y + ")")
                    .style("stroke-width", 1.5 / k + "px");

                // Call the function for the specific state
                handleStateClick(stateId);
            }

            // Handle the class for active state
            g.selectAll("path")
                .classed("active", focused && function(d) { return d === focused; });
        }

        function resetZoom() {
            focused = null;
            g.transition()
                .duration(750)
                .attr("transform", "")
                .style("stroke-width", "1.5px");
            g.selectAll("path").classed("active", false);
        }

        g.selectAll("path")
            .data(collection.features)
            .enter()
            .append("path")
            .attr("class", "state")
            .attr("d", geoPath)
            .on("click", clickPath); // Bind the clickPath function to the click event
    </script>

</body>
</html>
